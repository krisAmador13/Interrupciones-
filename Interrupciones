#include <Arduino.h>
#include<stdint.h>

//Definición de variables globales 
#define LED1 25
#define LED2 26
#define LED3 27
#define LED4 14
#define LED5 34
#define LED6 35
#define LED7 32
#define LED8 33
//Definimos los botones y el contador
#define bot1= 17
#define bot2= 28
#define bot3=19
//Establecemos el estado inicial de botones 
bool p_bot1 = LOW;
bool p_bot2 = LOW;
bool p_bot3 = LOW;
//Contadores para timer y botones 
uint8_t contador_B 
uint8_t contador_T

//Declaración de variables volátiles 
volatile int R; //Se establece la variable de reinicio 
volatile int suma; // Relacionada con el incremento del contador 
volatile int resta; //Relacionada con la disminución del contador 

//Variables para evitar el rebote de los botones 
unsigned long bot1_lF=0;
unsigned long bot2_lF=0;
unsigned long bot3_lF=0;
//Se establece el tiempo necesario entre pulsaciones para no considerarla un rebote 
unsigned long t_rebote_bot1 = 60; 
unsigned long t_rebote_bot2 = 60; 
unsigned long t_rebote_bot3 = 60; 
//Declaración de funciones de timer
void initTimer0();
void IRAM_ATTR Timer0_ISR();
//Declaración de funciones de botones 
void IRAM_ATTR B1_ISR();
void IRAM_ATTR B2_ISR();
void IRAM_ATTR B3_ISR();

void setup(){
//iniciación del timer 
 initTimer0();
//Iniciación de interrupción de botones 
 attachInterrupt(bot1, B1_ISR, CHANGE);
 attachInterrupt(bot2, B2_ISR, CHANGE);
 attachInterrupt(bot3, B3_ISR, CHANGE);
}



//Función que establece el timer 
void initTimer0(){
 //Seleccionar número de timer, Prescaler y Flag
 Timer0= timerBegin(0,80,true);
 //Definimos función de ISR
 timerAttachInterrupt(Timer0, &Timer0_ISR, true);
 //Definimos alarma y reload 
 timerAlarmWrite(Timer0, 25000, false);
 //Habilitamos el timer
 timerAlarmEnable(Timer0);
 void IRAM_ATTR B1_ISR();

//Hacer que incremente y decremente el contador
void IRAM_ATTR Timer0_ISR(){
    contador++;
    if (contador > 15) {
    contador = 0;
    } else if (contador < 0) {
      contador = 0;
    }
  
}
//Establecemos interrupciones de botón 
//Establecemos función de acción del boton de suma
void IRAM_ATTR B1_ISR(){
unsigned long t_actual = esp_timer_get_time() / 1000; //esp_timer_get_time() devuelve el tiempo actual en microsegundos desde que el microcontrolador comenzó a ejecutarse
if ((t_actual - bot1_lF) > t_rebote) {
 portEnter_Critical_ISR(&mux);//Entramos a la sección crítica
 contador_B++;
 if (contador_B > 15) {
      contadorBot = 0;
 }
}
unsigned long bot1_lF= t_actual; 
portExit_Critical_ISR(&mux);//Salimos de la sección crítica 
}
//Establecemos función de acción del boton de resta
void IRAM_ATTR B2_ISR(){
unsigned long t_actual = esp_timer_get_time() / 1000; //esp_timer_get_time() devuelve el tiempo actual en microsegundos desde que el microcontrolador comenzó a ejecutarse
if ((t_actual - bot2_lF) > t_rebote) {
 portEnter_Critical_ISR(&mux);//Entramos a la sección crítica
 if (contador_B > 0) {
      contador_B--;
 }
}
unsigned long bot2_lF= t_actual;
portExit_Critical_ISR(&mux);//Salimos de la sección crítica 
}
//Establecemos función de acción del boton de reinicio de contador de timer 
void IRAM_ATTR B3_ISR(){
unsigned long t_actual = esp_timer_get_time() / 1000; //esp_timer_get_time() devuelve el tiempo actual en microsegundos desde que el microcontrolador comenzó a ejecutarse
if ((t_actual - bot3_lF) > t_rebote) {
 portEnter_Critical_ISR(&mux);//Entramos a la sección crítica
      contador_T=0;
}
unsigned long bot3_lF= t_actual;
portExit_Critical_ISR(&mux);//Salimos de la sección crítica 
}

